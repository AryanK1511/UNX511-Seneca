# Week 05 Notes

Device drivers in Linux are specialized software components that allow the operating system (OS) to communicate with hardware devices.

Think of them as translators that help the OS understand how to control and interact with various hardware peripherals, such as:

- **Input Devices**: Keyboards and mice
- **Output Devices**: Printers and monitors
- **Storage Devices**: Hard drives and USB drives
- **Network Interfaces**: Ethernet and Wi-Fi adapters

## Types of Device Drivers

1. **Character Device Drivers**:

   - These allow the device to be accessed as a stream of bytes, similar to how we interact with files.
   - Examples include keyboards and serial ports.

2. **Block Device Drivers**:

   - These drivers manage devices that store data in fixed-size blocks.
   - They can be accessed via filesystem nodes, making them suitable for devices like hard drives.

3. **Network Device Drivers**:
   - These are responsible for controlling network devices, allowing communication over networks.

## Kernel Modules

- Device drivers can be built separately and then plugged into the Linux kernel.
- Each piece of code that can be added to a kernel at runtime is called a **module**.
- You can insert and remove modules from the kernel using the following commands:
  - To insert a module: `sudo insmod <module_name>.ko`
  - To remove a module: `sudo rmmod <module_name>`

## Licensing

Whenever you create a module, you need to implement a license using the macro `MODULE_LICENSE()`. This specifies the licensing terms under which your module can be used.

## Language and Syntax

- The Linux kernel is primarily written in **C**, and there is no support for C++.
- The version of C used in the kernel is slightly different, with some specific syntax.

## Initialization and Cleanup

- When the kernel loads a module, it calls the **init** function defined in the module. This is where you can set up device resources.
- When the module is removed, the **exit** function is called to clean up resources.

## Example of a Simple Device Driver

```c
#include <linux/module.h>  // Required for all modules
#include <linux/kernel.h>  // Required for KERN_INFO
#include <linux/fs.h>      // Required for file_operations

#define DEVICE_NAME "my_char_device"

static int __init my_driver_init(void) {
    printk(KERN_INFO "Initializing my character device\n");
    return 0;  // Return 0 indicates successful initialization
}

static void __exit my_driver_exit(void) {
    printk(KERN_INFO "Removing my character device\n");
}

module_init(my_driver_init);   // Macro to register the init function
module_exit(my_driver_exit);    // Macro to register the exit function
MODULE_LICENSE("GPL");          // Specify the license for the module
```

### Explanation of the Example

- **module_init()**: This macro registers the function that gets called when the module is loaded into the kernel.
- **module_exit()**: This macro registers the function that gets called when the module is removed from the kernel.
- **printk()**: This function is used for logging messages to the kernel log, `/var/log/messages`. `KERN_INFO` is a priority level for the log message.
- **MODULE_LICENSE("GPL")**: This indicates that the module is licensed under the GNU General Public License, which is a common license for open-source software.

## More concepts

- **User Space**: This is where user applications run. Applications in user space cannot directly access hardware or manage system resources.
- **Kernel Space**: This is where the kernel runs and has complete control over the system. Modules (like device drivers) run in kernel space, allowing them to interact directly with the hardware.

### Concurrency in Kernel Programming

When writing kernel modules, it’s important to consider that multiple processes may be accessing the same resources at the same time. This can lead to issues such as data corruption or race conditions if not properly managed.

**Key Concepts for Managing Concurrency:**

- **Locks**: Use locks to prevent multiple processes from accessing the same resource simultaneously. Common locking mechanisms in the kernel include spinlocks, mutexes, and read-write locks.

- **Atomic Operations**: Use atomic operations for small, critical sections of code where you need to ensure that a variable is updated without interruption.

- **Interrupts**: Be aware of how interrupts can affect concurrency. Proper handling of interrupts is crucial to ensure data integrity and system stability.

### Logging and Troubleshooting

To diagnose issues with your kernel module or device driver, check the system logs:

- Look in **/var/log/messages** or use `dmesg` command to view kernel messages. This can provide insights into any errors or warnings generated by your module.

### Character Device Drivers

When you create a character device driver, it will appear as a file under the `/dev` directory. However, it’s important to note that this file is not a regular file but a representation of the device in the filesystem.

- To list devices and check the types, use:

  ```bash
  ls -l /dev
  ```

- You will see output similar to this:

  ```bash
  crw-rw---- 1 root tty 4, 64 Oct  9 12:00 my_char_device
  ```

  In this output:

  - The `c` at the beginning indicates it’s a character device.
  - The `rw` indicates read and write permissions.
  - `4` is the **major number**, which identifies the driver associated with this device.
  - `64` is the **minor number**, which allows differentiation between devices managed by the same driver.

### Major and Minor Numbers

- **Major Number**: Identifies the driver associated with the device. Multiple devices can share the same major number if they are handled by the same driver.
- **Minor Number**: Allows the operating system to differentiate between devices that are managed by the same driver. This is especially useful for drivers managing multiple devices.

### Creating a Character Device

To create a character device in Linux, you typically need to define the major and minor numbers in your module:

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>

#define DEVICE_NAME "my_char_device"
#define MAJOR_NUM 240
#define MINOR_NUM 0

static int __init my_driver_init(void) {
    int ret = register_chrdev(MAJOR_NUM, DEVICE_NAME, NULL);
    if (ret < 0) {
        printk(KERN_ALERT "Failed to register char device\n");
        return ret;
    }
    printk(KERN_INFO "Char device registered with major number %d\n", MAJOR_NUM);
    return 0;  // Successful initialization
}

static void __exit my_driver_exit(void) {
    unregister_chrdev(MAJOR_NUM, DEVICE_NAME);
    printk(KERN_INFO "Char device unregistered\n");
}

module_init(my_driver_init);
module_exit(my_driver_exit);
MODULE_LICENSE("GPL");
```

- **register_chrdev()**: This function registers the character device with the specified major number and device name. If successful, it allows the device to be accessed via `/dev`.

- **unregister_chrdev()**: This function unregisters the device when the module is removed, cleaning up resources.

> **NOTE:** Using vim or cat on /proc/devices is a way to view the currently registered devices on your system. However, you won't be able to make any modifications, as this file is managed by the kernel and reflects the current state of device drivers.

## Detailed Examples

You can view detailed examples [here](./examples/). All the explanation is present in the form of comments in the code itself.
